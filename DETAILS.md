# BranchTracer

Implementation of Branch Tracer with C++

Branch data refers to the data processed in a branching situation such as jmp and call. This data is advantageous for showing the structure of binary regardless of the polymorphism. Branch tracer logs such branch data.

- Brancher DLL Main - Pre process :  [dllmain.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/dllmain.cpp)
- Branch Logger - VEH Handler: [Brancher.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/Brancher.cpp)
- Process Utils - Manage Break Points : [ProcessUtils.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/ProcessUtils.cpp)
- Raw level Helper - Asm Parser : [RawlevelHelper.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/RawlevelHelper.cpp)
- Helper Main - DLL Injector : [Main.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Helper/main.cpp)

## Brancher

Brancher is a VEH-based dll-type branch tracer.

VEH is a Vectored Exception Handler that can handle exceptions which occur throughout the binary. When dll is injected, dllmain sets an EXCEPTION_BREAKPOINT at the entry point of the target binary and add VEH as the first priority exception handler. When instruction pointer executes the entry point, int3 occurs and system calls VEH. Brancher's VEH handler parses opcode and logs it, if it is a branch instruction. The handler sets trap flag of the EFLags register. EXCEPTION_SINGLE_STEP will occur after VEH returns, then VEH can be called recursively. VEH can stepping the instruction and logs it, if it is branch instruction.

Despite the single step exception, the tracer is fast enough. Because the dll shares memory with the target process, so it is less expensive to access memory. And exception handler is used to process single step exception. In order to reduce unnecessary logging, I used a software break point when an API is called. Overwrite the return address of API with int3 and run the process without trap flag.

```cpp
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        AddVectoredExceptionHandler(1, BranchHandler);
        SetBreakPointOnEntryPoint();
        break;
    }
}
```

Brancher sets break point at the entry point and adds the VEH handler with first priority.

```cpp
long WINAPI BranchHandler(PEXCEPTION_POINTERS ExceptionInfo) {
	PEXCEPTION_RECORD record = ExceptionInfo->ExceptionRecord;
	PCONTEXT context = ExceptionInfo->ContextRecord;

	if (record->ExceptionCode == EXCEPTION_BREAKPOINT) {
		BackupBreakPoint(record->ExceptionAddress);
	}

	if (record->ExceptionCode == EXCEPTION_BREAKPOINT
		|| record->ExceptionCode == EXCEPTION_SINGLE_STEP)
	{
        ...
    }
}
```

The branch handler handles a single step exception and logs it when it is a branch instruction.

```cpp
if (opc[0] == 0xFF) {
    BYTE Reg = (opc[1] >> 0x3) & 0x7;
    if (Reg >= 2 && Reg <= 5) {
        // Binary 010(near call) or 011(far call)
        //        100(near jmp)  or 101(far jmp)

        LPVOID next;
        CDWORD called = GetBranchingAddress(opc, context, &next);

        StringCbPrintfW(log,
            MAX_LOG_SIZE,
            L"+%p,%p,%s,%s\r\n",
            record->ExceptionAddress,
            called,
            wModuleName,
            wSymbolName);

        WriteFile(hStdOutput, log, (DWORD)wcslen(log) * sizeof(WCHAR), &written, NULL);
    }
}
```

## Helper

Helper injects the Brancher dll into the target process.

By waiting for the created remote thread, it helps the normal operation of the process after the veh registration and break point creation.

```cpp
HANDLE hThread = CreateRemoteThread(pi.hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)lpFunction, lpParam, NULL, NULL);
WaitForSingleObject(hThread, INFINITE);

CloseHandle(hThread);
ResumeThread(pi.hThread);
```

## Log Example

Branch data generated by notepad

```
[notepad.txt]
+00007FF7E0E187D4,00007FF7E0E18F24,,
+00007FF7E0E18805,00007FFB57E1CC00,KERNEL32.DLL,GetStartupInfoW
+00007FF7E0E1889A,00007FFB580564F0,ntdll.dll,RtlQueryProcessHeapInformation
+00007FF7E0E188DC,00007FF7E0E18FFA,,
++ 1 times repeated ++
+00007FF7E0E18FFA,00007FFB570AA860,msvcrt.dll,initterm
+00007FF7E0E189CA,00007FFB57091480,msvcrt.dll,ismbblead
+00007FF7E0E18982,00007FF7E0E03B1C,,
+00007FF7E0E03B58,00007FF7E0E192F2,,
++ 12 times repeated ++
+00007FF7E0E192F2,00007FFB570E4080,msvcrt.dll,memset
+00007FF7E0E03B5D,00007FFB57E1EBE0,KERNEL32.DLL,GetCommandLineW
+00007FF7E0E03BA0,00007FFB57FD2810,ntdll.dll,EtwEventRegister
+00007FF7E0E03BBF,00007FFB57FD25C0,ntdll.dll,EtwEventSetInformation
+00007FF7E0E03BCF,00007FFB57415440,combase.dll,CoCreateGuid
+00007FF7E0E03C5E,00007FFB57E1F5D0,KERNEL32.DLL,HeapSetInformation
+00007FF7E0E03C6B,00007FFB5746D850,combase.dll,CoInitializeEx
+00007FF7E0E03CA4,00007FFB5794A180,USER32.dll,CharNextW
+00007FF7E0E03CD0,00007FF7E0E07D14,,
+00007FF7E0E07D31,00007FF7E0E19340,,
++ 12 times repeated ++
```
