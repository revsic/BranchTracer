# BranchTracer

Implementation of Branch Tracer with C++

Branch data refers to data processed in a branching situation such as jmp and call. This data is advantageous for showing the structure of binary regardless of the polymorphism. Branch tracer logs such branch data.

- Brancher DLL Main - Pre process :  [dllmain.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/dllmain.cpp)
- Branch Logger - VEH Handler: [Brancher.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/Brancher.cpp)
- Process Utils - Manage Break Points : [ProcessUtils.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/ProcessUtils.cpp)
- Raw level Helper - Asm Parser : [RawlevelHelper.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Brancher/RawlevelHelper.cpp)
- Helper Main - DLL Injector : [Main.cpp](https://github.com/revsic/BranchTracer/blob/master/Brancher/Helper/main.cpp)

## Brancher

Brancher is a VEH-based dll-type branch tracer.

VEH is a Vectored Exception Handler that can handle exceptions which occur throughout the binary. When dll is injected, dllmain sets an EXCEPTION_BREAKPOINT at the entry point of the target binary and add VEH as the first priority. When instruction pointer executes the entry point, int3 occurs and system call VEH. The handler parses opcode and logs if it is a branch instruction. The handler sets trap flag of the EFLags register. EXCEPTION_SINGLE_STEP will occur after the VEH returns, then the VEH can be called recursively. The VEH can stepping the instruction and logs if it is branch instruction.

Despite the single step exception, the tracer is fast enough. Because the dll shares memory with the target process, so it is less expensive to access memory. And exception handler is used to speed up single step exception processing. In order to reduce unnecessary logging, I used a software break point when an API is called. Overwrite return address of API with int3 and run the process without trap flag.

```cpp
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        AddVectoredExceptionHandler(1, BranchHandler);
        SetBreakPointOnEntryPoint();
        break;
    }
}
```

Brancher sets break point at the entry point and registers the VEH handler with first priority.

```cpp
long WINAPI BranchHandler(PEXCEPTION_POINTERS ExceptionInfo) {
	PEXCEPTION_RECORD record = ExceptionInfo->ExceptionRecord;
	PCONTEXT context = ExceptionInfo->ContextRecord;

	if (record->ExceptionCode == EXCEPTION_BREAKPOINT) {
		BackupBreakPoint(record->ExceptionAddress);
	}

	if (record->ExceptionCode == EXCEPTION_BREAKPOINT
		|| record->ExceptionCode == EXCEPTION_SINGLE_STEP)
	{
        ...
    }
}
```

The branch handler handles a single step exception and logs when the instruction is branching.

```cpp
if (opc[0] == 0xFF) {
    BYTE Reg = (opc[1] >> 0x3) & 0x7;
    if (Reg >= 2 && Reg <= 5) {
        // Binary 010(near call) or 011(far call)
        //        100(near jmp)  or 101(far jmp)

        LPVOID next;
        CDWORD called = GetBranchingAddress(opc, context, &next);

        StringCbPrintfW(log,
            MAX_LOG_SIZE,
            L"+%p,%p,%s,%s\r\n",
            record->ExceptionAddress,
            called,
            wModuleName,
            wSymbolName);

        WriteFile(hStdOutput, log, (DWORD)wcslen(log) * sizeof(WCHAR), &written, NULL);
    }
}
```

## Helper

Helper injects the Brancher dll into the target process.

By waiting for the created remote thread, it helps the normal operation of the process after the veh registration and break point creation.

```cpp
HANDLE hThread = CreateRemoteThread(pi.hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)lpFunction, lpParam, NULL, NULL);
WaitForSingleObject(hThread, INFINITE);

CloseHandle(hThread);
ResumeThread(pi.hThread);
```

## Log Example

Branch data generated by notepad

```
[notepad.txt]
+00007FF7E0E187D4,00007FF7E0E18F24,,
+00007FF7E0E18805,00007FFB57E1CC00,KERNEL32.DLL,GetStartupInfoW
+00007FF7E0E1889A,00007FFB580564F0,ntdll.dll,RtlQueryProcessHeapInformation
+00007FF7E0E188DC,00007FF7E0E18FFA,,
++ 1 times repeated ++
+00007FF7E0E18FFA,00007FFB570AA860,msvcrt.dll,initterm
+00007FF7E0E189CA,00007FFB57091480,msvcrt.dll,ismbblead
+00007FF7E0E18982,00007FF7E0E03B1C,,
+00007FF7E0E03B58,00007FF7E0E192F2,,
++ 12 times repeated ++
+00007FF7E0E192F2,00007FFB570E4080,msvcrt.dll,memset
+00007FF7E0E03B5D,00007FFB57E1EBE0,KERNEL32.DLL,GetCommandLineW
+00007FF7E0E03BA0,00007FFB57FD2810,ntdll.dll,EtwEventRegister
+00007FF7E0E03BBF,00007FFB57FD25C0,ntdll.dll,EtwEventSetInformation
+00007FF7E0E03BCF,00007FFB57415440,combase.dll,CoCreateGuid
+00007FF7E0E03C5E,00007FFB57E1F5D0,KERNEL32.DLL,HeapSetInformation
+00007FF7E0E03C6B,00007FFB5746D850,combase.dll,CoInitializeEx
+00007FF7E0E03CA4,00007FFB5794A180,USER32.dll,CharNextW
+00007FF7E0E03CD0,00007FF7E0E07D14,,
+00007FF7E0E07D31,00007FF7E0E19340,,
++ 12 times repeated ++
```
